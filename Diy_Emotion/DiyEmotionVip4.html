<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Sticker Designer - Pro Editor</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@500;700;900&display=swap');
        body {
            font-family: 'SF Pro Display', 'Noto Sans SC', -apple-system, sans-serif;
            background-color: #f5f5f7;
            color: #1d1d1f;
            -webkit-font-smoothing: antialiased;
        }
        .preview-zone {
            background-image: radial-gradient(#d2d2d7 1px, #f5f5f7 1px);
            background-size: 24px 24px;
            border-radius: 40px;
            touch-action: none;
            transition: all 0.3s ease;
        }
        #floatingInput {
            display: none;
            position: absolute;
            z-index: 100;
            background: rgba(255,255,255,0.9);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.2);
            border: 1px solid rgba(210,210,213,0.5);
            padding: 18px;
            width: 300px;
        }
        .apple-modal {
            display: none;
            position: fixed;
            inset: 0;
            z-index: 999;
            background: rgba(0,0,0,0.3);
            backdrop-filter: blur(15px);
            align-items: center;
            justify-content: center;
        }
        .ios-switch:checked ~ .switch-dot { transform: translateX(1.25rem); background-color: white; }
    </style>
</head>
<body class="min-h-screen flex flex-col">

    <input type="file" id="avatarUpload" class="hidden" accept="image/*" onchange="handleAvatarUpload(event)">

    <div id="unlockModal" class="apple-modal">
        <div class="bg-white w-[85%] max-w-sm rounded-[32px] p-10 text-center shadow-2xl mx-4">
            <div class="text-4xl mb-4">✨</div>
            <h2 class="text-2xl font-bold mb-2">解锁高级权限</h2>
            <p class="text-gray-500 text-sm mb-8 leading-relaxed">
                微信号 <span class="text-blue-600 font-bold select-all">857023577</span> 已复制<br>
                请添加作者微信获取专属解锁码
            </p>
            <input type="text" id="unlockInput" class="w-full px-4 py-4 bg-gray-100 rounded-2xl mb-4 text-center text-lg font-bold outline-none border-2 border-transparent focus:border-blue-500 transition-all" placeholder="输入解锁码">
            <div class="flex flex-col gap-2">
                <button onclick="confirmUnlock()" class="w-full py-4 bg-black text-white rounded-2xl font-bold">验证并解锁</button>
                <button onclick="closeModal()" class="w-full py-2 text-gray-400 text-sm">稍后再说</button>
            </div>
        </div>
    </div>

    <header class="max-w-6xl mx-auto w-full px-6 pt-16 pb-8 text-center">
        <h1 class="text-4xl md:text-5xl font-black tracking-tight mb-4">表情包工作室 <span class="text-blue-600">Pro</span></h1>
        <p class="text-gray-500 text-base md:text-lg font-medium">所见即所得 · 支持透明 PNG · 智能排版</p>
    </header>

    <section class="w-full flex-grow flex flex-col items-center justify-center p-4 relative">
        <div class="relative preview-zone p-4 md:p-12 shadow-xl bg-white border border-gray-100">
            <canvas id="mainCanvas" width="800" height="400" class="max-w-full h-auto cursor-move"></canvas>
            
            <div id="floatingInput">
                <textarea id="tempText" class="w-full p-4 text-sm bg-gray-50 rounded-xl border-none focus:ring-2 focus:ring-blue-400 outline-none resize-none" rows="3"></textarea>
                <div class="flex justify-between items-center mt-3">
                    <span class="text-[10px] text-gray-400 font-bold uppercase">Text Editor</span>
                    <button onclick="saveFloatingText()" class="bg-black text-white px-8 py-2.5 rounded-full text-xs font-bold transition active:scale-95">应用修改</button>
                </div>
            </div>
        </div>

        <div class="mt-10">
            <button onclick="downloadImage()" class="bg-black text-white px-16 py-5 rounded-full font-black text-lg shadow-2xl hover:bg-zinc-800 transition active:scale-95">
                导出高清表情包
            </button>
        </div>
    </section>

    <section class="max-w-6xl mx-auto w-full px-6 py-12">
        <div class="bg-white/80 backdrop-blur-xl border border-white p-8 rounded-[40px] shadow-sm grid grid-cols-1 md:grid-cols-3 gap-10">
            <div class="space-y-5">
                <h3 class="text-xs font-black text-gray-400 uppercase tracking-widest">Style Palette / 配色</h3>
                <div class="flex items-center gap-5">
                    <button onclick="updateColor('#07C160')" class="w-12 h-12 rounded-2xl bg-[#07C160] shadow-inner"></button>
                    <button onclick="updateColor('#10aeff')" class="w-12 h-12 rounded-2xl bg-[#10aeff] shadow-inner"></button>
                    <button onclick="updateColor('#FF5252')" class="w-12 h-12 rounded-2xl bg-[#FF5252] shadow-inner"></button>
                    <div class="w-px h-10 bg-gray-200"></div>
                    <div class="relative" onclick="handleColorLock(event)">
                        <input type="color" oninput="updateColor(this.value)" class="w-12 h-12 border-none bg-transparent cursor-pointer">
                    </div>
                </div>
            </div>

            <div class="space-y-5">
                <h3 class="text-xs font-black text-gray-400 uppercase tracking-widest">Avatar / 头像遮罩</h3>
                <label class="flex items-center gap-4 cursor-pointer group">
                    <div class="relative flex items-center">
                        <input type="checkbox" id="maskToggle" checked onchange="handleMaskChange(this)" class="sr-only ios-switch">
                        <div class="w-12 h-7 bg-gray-200 rounded-full transition-colors peer-checked:bg-blue-600"></div>
                        <div class="switch-dot absolute left-1 top-1 w-5 h-5 bg-white rounded-full transition-transform shadow-sm"></div>
                    </div>
                    <span class="text-sm font-bold text-gray-700">圆形遮罩 (关闭以支持透明PNG)</span>
                </label>
            </div>

            <div class="space-y-5">
                <h3 class="text-xs font-black text-gray-400 uppercase tracking-widest">Badge / 挂件设置</h3>
                <div class="flex items-center gap-3 bg-gray-100 p-2 rounded-2xl">
                    <input type="checkbox" id="badgeToggle" checked onchange="handleBadgeRequest(this)" class="mx-3 w-5 h-5 accent-black">
                    <input type="text" id="badgeText" maxlength="6" value="艾兜兜儿" class="flex-1 bg-white px-4 py-2.5 rounded-xl text-sm font-black outline-none shadow-sm" oninput="refreshBadge()">
                </div>
            </div>
        </div>
    </section>

    <footer class="footer-container">
        <div class="max-w-6xl mx-auto px-6 text-center text-[#86868b] text-[11px] font-bold tracking-widest uppercase">
            DESIGNED BY I DO IT · © 2024-2026
        </div>
    </footer>

    <script>
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const UNLOCK_CODE = "BQWX857023577";
        const AUTHOR_WECHAT = "BQWX857023577";
        let isUnlocked = false;

        let state = {
            text: "优秀！",
            bgColor: '#07C160',
            avatar: null,
            badge: "艾兜兜儿",
            showBadge: true,
            isCircleMask: true,
            textPos: { x: 140, y: 140 },
            dragging: false,
            dragOffset: { x: 0, y: 0 },
            avatarRenderRect: { x: 0, y: 0, w: 0, h: 0 },
            bubbleBounds: { x: 0, y: 0, w: 0, h: 0 }
        };

        window.onload = () => {
            initAvatar();
            setupInteractions();
        };

        function initAvatar() {
            const img = new Image();
            img.crossOrigin = "anonymous";
            // 默认透明头像（如果指定链接失效，会保留逻辑）
            img.src = "https://images.zsxq.com/FjJCljNf3_Zkd_4c1HAaevGQ4ZQ6?imageMogr2/auto-orient/thumbnail/750x/format/jpg/blur/1x0/quality/75&e=1772294399&s=mtttmjytmmyjyj&token=kIxbL07-8jAj8w1n4s9zv64FuZZNEATmlU_Vm6zD:3q3csBXHxw8-oDJOAzReRedm6EY=";
            img.onload = () => { state.avatar = img; draw(); };
        }

        function draw(targetCtx = ctx, isExport = false) {
            // 清除画布（核心修复：防止透明PNG残留）
            targetCtx.clearRect(0, 0, canvas.width, canvas.height);
            
            const lines = state.text.split('\n');
            const isSingleLine = lines.length === 1;
            const fontSize = isSingleLine ? 64 : 46; 
            targetCtx.font = `italic 900 ${fontSize}px 'Noto Sans SC'`;
            
            let maxW = 0;
            lines.forEach(l => {
                const w = targetCtx.measureText(l).width;
                if(w > maxW) maxW = w;
            });

            const avatarSize = 130;
            const paddingH = 55; 
            const paddingV = isSingleLine ? 35 : 45;
            const avatarMargin = 35;
            
            const bW = Math.max(340, maxW + avatarSize + avatarMargin + (paddingH * 2));
            const lineH = fontSize * 1.3;
            const textTotalHeight = lines.length * lineH;
            const bH = Math.max(avatarSize + 20, textTotalHeight + (paddingV * 2));

            const bx = state.textPos.x - paddingH;
            const by = state.textPos.y - paddingV;
            state.bubbleBounds = { x: bx - 20, y: by - 20, w: bW + 40, h: bH + 60 };

            // 1. 绘制气泡
            targetCtx.save();
            if(!isExport) {
                targetCtx.shadowColor = 'rgba(0,0,0,0.12)';
                targetCtx.shadowBlur = 20;
                targetCtx.shadowOffsetY = 8;
            }
            targetCtx.fillStyle = state.bgColor;
            drawRoundRect(targetCtx, bx, by, bW, bH, 48);
            
            // 气泡尾巴
            targetCtx.beginPath();
            targetCtx.moveTo(bx + 60, by + bH);
            targetCtx.lineTo(bx + 40, by + bH + 25);
            targetCtx.lineTo(bx + 95, by + bH);
            targetCtx.fill();
            targetCtx.restore();

            // 2. 文字
            targetCtx.save();
            targetCtx.fillStyle = "#FFFFFF";
            targetCtx.textBaseline = 'middle';
            const centerY = by + bH / 2;
            const startY = centerY - ((lines.length - 1) * lineH / 2);
            lines.forEach((l, i) => {
                targetCtx.fillText(l, state.textPos.x, startY + (i * lineH));
            });
            targetCtx.restore();

            // 3. 头像渲染 (关键Bug修复逻辑)
            if(state.avatar) {
                const ax = bx + bW - avatarSize - 35;
                const ay = by + (bH - avatarSize) / 2;
                state.avatarRenderRect = { x: ax, y: ay, w: avatarSize, h: avatarSize };
                
                targetCtx.save();
                if(state.isCircleMask) {
                    targetCtx.beginPath();
                    targetCtx.arc(ax + avatarSize/2, ay + avatarSize/2, avatarSize/2, 0, Math.PI*2);
                    targetCtx.clip();
                }
                // 绘制头像
                targetCtx.drawImage(state.avatar, ax, ay, avatarSize, avatarSize);
                targetCtx.restore();

                // 4. 挂件
                if(state.showBadge) {
                    targetCtx.save();
                    targetCtx.font = "bold 15px Arial";
                    const btxtW = targetCtx.measureText(state.badge).width + 28;
                    const btxtH = 32;
                    const bpx = ax + avatarSize - btxtW/1.5;
                    const bpy = ay - 12;

                    targetCtx.shadowBlur = 10;
                    targetCtx.shadowColor = 'rgba(0,0,0,0.1)';
                    targetCtx.fillStyle = "white";
                    drawRoundRect(targetCtx, bpx, bpy, btxtW, btxtH, 16);
                    
                    targetCtx.beginPath();
                    targetCtx.moveTo(bpx + btxtW/2 + 6, bpy + btxtH);
                    targetCtx.lineTo(bpx + btxtW/2, bpy + btxtH + 8);
                    targetCtx.lineTo(bpx + btxtW/2 - 6, bpy + btxtH);
                    targetCtx.fill();

                    targetCtx.fillStyle = "#1d1d1f";
                    targetCtx.textAlign = "center";
                    targetCtx.textBaseline = "middle";
                    targetCtx.fillText(state.badge, bpx + btxtW/2, bpy + btxtH/2 + 1);
                    targetCtx.restore();
                }
            }
        }

        function setupInteractions() {
            const getCanvasPos = (e) => {
                const rect = canvas.getBoundingClientRect();
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const clientY = e.touches ? e.touches[0].clientY : e.clientY;
                return {
                    x: (clientX - rect.left) * (canvas.width / rect.width),
                    y: (clientY - rect.top) * (canvas.height / rect.height),
                    rawX: clientX, rawY: clientY
                };
            };

            canvas.addEventListener('mousedown', (e) => {
                const p = getCanvasPos(e);
                state.dragging = true;
                state.dragOffset = { x: p.x - state.textPos.x, y: p.y - state.textPos.y };
                state.clickStartTime = Date.now();
                state.lastPos = p;
            });

            window.addEventListener('mousemove', (e) => {
                if (!state.dragging) return;
                const p = getCanvasPos(e);
                state.textPos = { x: p.x - state.dragOffset.x, y: p.y - state.dragOffset.y };
                draw();
            });

            window.addEventListener('mouseup', (e) => {
                if (Date.now() - state.clickStartTime < 200) {
                    const p = state.lastPos;
                    const av = state.avatarRenderRect;
                    if(p.x > av.x && p.x < av.x + av.w && p.y > av.y && p.y < av.y + av.h) {
                        document.getElementById('avatarUpload').click();
                    } else {
                        showEditor(p.rawX, p.rawY);
                    }
                }
                state.dragging = false;
            });

            // 触摸支持
            canvas.addEventListener('touchstart', (e) => { 
                const p = getCanvasPos(e);
                state.dragging = true;
                state.dragOffset = { x: p.x - state.textPos.x, y: p.y - state.textPos.y };
                state.clickStartTime = Date.now();
                state.lastPos = p;
                e.preventDefault();
            }, {passive: false});

            window.addEventListener('touchmove', (e) => {
                if (!state.dragging) return;
                const p = getCanvasPos(e);
                state.textPos = { x: p.x - state.dragOffset.x, y: p.y - state.dragOffset.y };
                draw();
            }, {passive: false});

            window.addEventListener('touchend', () => state.dragging = false);
        }

        function downloadImage() {
            const tempCanvas = document.createElement('canvas');
            const b = state.bubbleBounds;
            const scale = 2; // 高清导出
            tempCanvas.width = b.w * scale;
            tempCanvas.height = b.h * scale;
            const tCtx = tempCanvas.getContext('2d');
            tCtx.scale(scale, scale);
            tCtx.translate(-b.x, -b.y);
            
            // 这里的 canvas 是当前页面的 canvas，由于 draw 函数内部用了 canvas.width，
            // 我们需要临时克隆 state 以免影响主画布
            draw(tCtx, true);

            const link = document.createElement('a');
            link.download = `Sticker-${Date.now()}.png`;
            link.href = tempCanvas.toDataURL('image/png', 1.0);
            link.click();
        }

        // 其他逻辑保持不变
        function showEditor(x, y) {
            const el = document.getElementById('floatingInput');
            el.style.display = 'block';
            el.style.left = `${Math.min(window.innerWidth - 320, x)}px`;
            el.style.top = `${y}px`;
            document.getElementById('tempText').value = state.text;
            document.getElementById('tempText').focus();
        }
        function saveFloatingText() {
            state.text = document.getElementById('tempText').value;
            document.getElementById('floatingInput').style.display = 'none';
            draw();
        }
        function handleAvatarUpload(e) {
            const file = e.target.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => {
                const img = new Image();
                img.onload = () => { state.avatar = img; draw(); };
                img.src = ev.target.result;
            }
            reader.readAsDataURL(file);
        }
        function handleMaskChange(cb) { state.isCircleMask = cb.checked; draw(); }
        function updateColor(c) {
            if (isUnlocked || ['#07C160', '#10aeff', '#ff5252'].includes(c.toLowerCase())) {
                state.bgColor = c; draw();
            } else { triggerUnlock(); }
        }
        function handleBadgeRequest(cb) {
            if (!isUnlocked) { cb.checked = false; triggerUnlock(); }
            else { state.showBadge = cb.checked; draw(); }
        }
        function triggerUnlock() {
            navigator.clipboard.writeText(AUTHOR_WECHAT).then(() => {
                document.getElementById('unlockModal').style.display = 'flex';
            });
        }
        function confirmUnlock() {
            if (document.getElementById('unlockInput').value === UNLOCK_CODE) {
                isUnlocked = true; closeModal(); draw();
            } else { alert("验证码错误"); }
        }
        function closeModal() { document.getElementById('unlockModal').style.display = 'none'; }
        function drawRoundRect(ctx, x, y, w, h, r) {
            ctx.beginPath();
            ctx.moveTo(x + r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.fill();
        }
        function refreshBadge() {
            state.badge = document.getElementById('badgeText').value || "";
            draw();
        }
    </script>
</body>
</html>
